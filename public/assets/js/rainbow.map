{"version":3,"sources":["webpack:///webpack/bootstrap fd80cbb4cee82f72f997","webpack:///./public/assets/libs/rainbow.js","webpack:///./public/assets/libs/rainbow.generic.js","webpack:///./public/assets/libs/rainbow.go.js","webpack:///./public/assets/libs/rainbow.javascript.js","webpack:///./public/assets/libs/rainbow.php.js","webpack:///./public/assets/libs/rainbow.shell.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA,mBAAkB;AAClB;AACA,mCAAkC;;AAElC;AACA;AACA;AACA,mBAAkB;AAClB;AACA,+BAA8B;;AAE9B;AACA;AACA;AACA,mBAAkB;AAClB;AACA,6BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,KAAK;AACpB,gBAAe,OAAO;AACtB,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB,gBAAe,OAAO;AACtB,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,kBAAiB;AACjB;AACA;AACA,wCAAuC,sBAAsB,wBAAwB,WAAW;AAChG;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,OAAO;AAC9B,wBAAuB,MAAM;AAC7B,wBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAA+B,OAAO;AACtC,gCAA+B,OAAO;AACtC,gCAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,iBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,MAAM;AACzB,oBAAmB,OAAO;AAC1B,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,MAAM;AACrB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB;AACrB,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,uBAAuB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,wBAAwB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,EAAE;AACrB,oBAAmB,EAAE;AACrB,oBAAmB,aAAa;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;;;;;;;;;AC7xBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,EAAE;AAC1C;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,2CAA0C;AAC1C,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,yCAAwC,EAAE;AAC1C;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,2CAA0C;AAC1C,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;;AAEA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,EAAE;AACpC,cAAa;AACb;AACA;AACA,UAAS;AACT,8CAA6C,IAAI;AACjD,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iCAAgC,GAAG;AACnC;AACA;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,iCAAgC,GAAG;AACnC,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,kDAAiD;AACjD,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA,0BAAyB,eAAe;AACxC,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,8CAA6C;AAC7C,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,iIAAgI,OAAO;AACvI,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,kDAAiD;AACjD,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA,yBAAwB,KAAK,MAAM;AACnC,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,oCAAmC,GAAG,EAAE;AACxC,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/assets/js/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap fd80cbb4cee82f72f997\n **/","/**\n * Copyright 2013 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Rainbow is a simple code syntax highlighter\n *\n * @preserve @version 1.2\n * @url rainbowco.de\n */\nwindow['Rainbow'] = (function() {\n\n    /**\n     * array of replacements to process at the end\n     *\n     * @type {Object}\n     */\n    var replacements = {},\n\n        /**\n         * an array of start and end positions of blocks to be replaced\n         *\n         * @type {Object}\n         */\n        replacement_positions = {},\n\n        /**\n         * an array of the language patterns specified for each language\n         *\n         * @type {Object}\n         */\n        language_patterns = {},\n\n        /**\n         * an array of languages and whether they should bypass the default patterns\n         *\n         * @type {Object}\n         */\n        bypass_defaults = {},\n\n        /**\n         * processing level\n         *\n         * replacements are stored at this level so if there is a sub block of code\n         * (for example php inside of html) it runs at a different level\n         *\n         * @type {number}\n         */\n        CURRENT_LEVEL = 0,\n\n        /**\n         * constant used to refer to the default language\n         *\n         * @type {number}\n         */\n        DEFAULT_LANGUAGE = 0,\n\n        /**\n         * used as counters so we can selectively call setTimeout\n         * after processing a certain number of matches/replacements\n         *\n         * @type {number}\n         */\n        match_counter = 0,\n\n        /**\n         * @type {number}\n         */\n        replacement_counter = 0,\n\n        /**\n         * @type {null|string}\n         */\n        global_class,\n\n        /**\n         * @type {null|Function}\n         */\n        onHighlight;\n\n    /**\n     * cross browser get attribute for an element\n     *\n     * @see http://stackoverflow.com/questions/3755227/cross-browser-javascript-getattribute-method\n     *\n     * @param {Node} el\n     * @param {string} attr     attribute you are trying to get\n     * @returns {string|number}\n     */\n    function _attr(el, attr, attrs, i) {\n        var result = (el.getAttribute && el.getAttribute(attr)) || 0;\n\n        if (!result) {\n            attrs = el.attributes;\n\n            for (i = 0; i < attrs.length; ++i) {\n                if (attrs[i].nodeName === attr) {\n                    return attrs[i].nodeValue;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * adds a class to a given code block\n     *\n     * @param {Element} el\n     * @param {string} class_name   class name to add\n     * @returns void\n     */\n    function _addClass(el, class_name) {\n        el.className += el.className ? ' ' + class_name : class_name;\n    }\n\n    /**\n     * checks if a block has a given class\n     *\n     * @param {Element} el\n     * @param {string} class_name   class name to check for\n     * @returns {boolean}\n     */\n    function _hasClass(el, class_name) {\n        return (' ' + el.className + ' ').indexOf(' ' + class_name + ' ') > -1;\n    }\n\n    /**\n     * gets the language for this block of code\n     *\n     * @param {Element} block\n     * @returns {string|null}\n     */\n    function _getLanguageForBlock(block) {\n\n        // if this doesn't have a language but the parent does then use that\n        // this means if for example you have: <pre data-language=\"php\">\n        // with a bunch of <code> blocks inside then you do not have\n        // to specify the language for each block\n        var language = _attr(block, 'data-language') || _attr(block.parentNode, 'data-language');\n\n        // this adds support for specifying language via a css class\n        // you can use the Google Code Prettify style: <pre class=\"lang-php\">\n        // or the HTML5 style: <pre><code class=\"language-php\">\n        if (!language) {\n            var pattern = /\\blang(?:uage)?-(\\w+)/,\n                match = block.className.match(pattern) || block.parentNode.className.match(pattern);\n\n            if (match) {\n                language = match[1];\n            }\n        }\n\n        return language;\n    }\n\n    /**\n     * makes sure html entities are always used for tags\n     *\n     * @param {string} code\n     * @returns {string}\n     */\n    function _htmlEntities(code) {\n        return code.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&(?![\\w\\#]+;)/g, '&amp;');\n    }\n\n    /**\n     * determines if a new match intersects with an existing one\n     *\n     * @param {number} start1    start position of existing match\n     * @param {number} end1      end position of existing match\n     * @param {number} start2    start position of new match\n     * @param {number} end2      end position of new match\n     * @returns {boolean}\n     */\n    function _intersects(start1, end1, start2, end2) {\n        if (start2 >= start1 && start2 < end1) {\n            return true;\n        }\n\n        return end2 > start1 && end2 < end1;\n    }\n\n    /**\n     * determines if two different matches have complete overlap with each other\n     *\n     * @param {number} start1   start position of existing match\n     * @param {number} end1     end position of existing match\n     * @param {number} start2   start position of new match\n     * @param {number} end2     end position of new match\n     * @returns {boolean}\n     */\n    function _hasCompleteOverlap(start1, end1, start2, end2) {\n\n        // if the starting and end positions are exactly the same\n        // then the first one should stay and this one should be ignored\n        if (start2 == start1 && end2 == end1) {\n            return false;\n        }\n\n        return start2 <= start1 && end2 >= end1;\n    }\n\n    /**\n     * determines if the match passed in falls inside of an existing match\n     * this prevents a regex pattern from matching inside of a bigger pattern\n     *\n     * @param {number} start - start position of new match\n     * @param {number} end - end position of new match\n     * @returns {boolean}\n     */\n    function _matchIsInsideOtherMatch(start, end) {\n        for (var key in replacement_positions[CURRENT_LEVEL]) {\n            key = parseInt(key, 10);\n\n            // if this block completely overlaps with another block\n            // then we should remove the other block and return false\n            if (_hasCompleteOverlap(key, replacement_positions[CURRENT_LEVEL][key], start, end)) {\n                delete replacement_positions[CURRENT_LEVEL][key];\n                delete replacements[CURRENT_LEVEL][key];\n            }\n\n            if (_intersects(key, replacement_positions[CURRENT_LEVEL][key], start, end)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * takes a string of code and wraps it in a span tag based on the name\n     *\n     * @param {string} name     name of the pattern (ie keyword.regex)\n     * @param {string} code     block of code to wrap\n     * @returns {string}\n     */\n    function _wrapCodeInSpan(name, code) {\n        return '<span class=\"' + name.replace(/\\./g, ' ') + (global_class ? ' ' + global_class : '') + '\">' + code + '</span>';\n    }\n\n    /**\n     * finds out the position of group match for a regular expression\n     *\n     * @see http://stackoverflow.com/questions/1985594/how-to-find-index-of-groups-in-match\n     *\n     * @param {Object} match\n     * @param {number} group_number\n     * @returns {number}\n     */\n    function _indexOfGroup(match, group_number) {\n        var index = 0,\n            i;\n\n        for (i = 1; i < group_number; ++i) {\n            if (match[i]) {\n                index += match[i].length;\n            }\n        }\n\n        return index;\n    }\n\n    /**\n     * matches a regex pattern against a block of code\n     * finds all matches that should be processed and stores the positions\n     * of where they should be replaced within the string\n     *\n     * this is where pretty much all the work is done but it should not\n     * be called directly\n     *\n     * @param {RegExp} pattern\n     * @param {string} code\n     * @returns void\n     */\n    function _processPattern(regex, pattern, code, callback)\n    {\n        if (typeof regex === \"undefined\" || regex === null) {\n            //console.warn(\"undefined regular expression\")\n            return callback();\n        }\n        var match = regex.exec(code);\n\n        if (!match) {\n            return callback();\n        }\n\n        ++match_counter;\n\n        // treat match 0 the same way as name\n        if (!pattern['name'] && typeof pattern['matches'][0] == 'string') {\n            pattern['name'] = pattern['matches'][0];\n            delete pattern['matches'][0];\n        }\n\n        var replacement = match[0],\n            start_pos = match.index,\n            end_pos = match[0].length + start_pos,\n\n            /**\n             * callback to process the next match of this pattern\n             */\n            processNext = function() {\n                var nextCall = function() {\n                    _processPattern(regex, pattern, code, callback);\n                };\n\n                // every 100 items we process let's call set timeout\n                // to let the ui breathe a little\n                return match_counter % 100 > 0 ? nextCall() : setTimeout(nextCall, 0);\n            };\n\n        // if this is not a child match and it falls inside of another\n        // match that already happened we should skip it and continue processing\n        if (_matchIsInsideOtherMatch(start_pos, end_pos)) {\n            return processNext();\n        }\n\n        /**\n         * callback for when a match was successfully processed\n         *\n         * @param {string} replacement\n         * @returns void\n         */\n        var onMatchSuccess = function(replacement) {\n                // if this match has a name then wrap it in a span tag\n                if (pattern['name']) {\n                    replacement = _wrapCodeInSpan(pattern['name'], replacement);\n                }\n\n                // console.log('LEVEL', CURRENT_LEVEL, 'replace', match[0], 'with', replacement, 'at position', start_pos, 'to', end_pos);\n\n                // store what needs to be replaced with what at this position\n                if (!replacements[CURRENT_LEVEL]) {\n                    replacements[CURRENT_LEVEL] = {};\n                    replacement_positions[CURRENT_LEVEL] = {};\n                }\n\n                replacements[CURRENT_LEVEL][start_pos] = {\n                    'replace': match[0],\n                    'with': replacement\n                };\n\n                // store the range of this match so we can use it for comparisons\n                // with other matches later\n                replacement_positions[CURRENT_LEVEL][start_pos] = end_pos;\n\n                // process the next match\n                processNext();\n            },\n\n            // if this pattern has sub matches for different groups in the regex\n            // then we should process them one at a time by rerunning them through\n            // this function to generate the new replacement\n            //\n            // we run through them backwards because the match position of earlier\n            // matches will not change depending on what gets replaced in later\n            // matches\n            group_keys = keys(pattern['matches']),\n\n            /**\n             * callback for processing a sub group\n             *\n             * @param {number} i\n             * @param {Array} group_keys\n             * @param {Function} callback\n             */\n            processGroup = function(i, group_keys, callback) {\n                if (i >= group_keys.length) {\n                    return callback(replacement);\n                }\n\n                var processNextGroup = function() {\n                        processGroup(++i, group_keys, callback);\n                    },\n                    block = match[group_keys[i]];\n\n                // if there is no match here then move on\n                if (!block) {\n                    return processNextGroup();\n                }\n\n                var group = pattern['matches'][group_keys[i]],\n                    language = group['language'],\n\n                    /**\n                     * process group is what group we should use to actually process\n                     * this match group\n                     *\n                     * for example if the subgroup pattern looks like this\n                     * 2: {\n                     *     'name': 'keyword',\n                     *     'pattern': /true/g\n                     * }\n                     *\n                     * then we use that as is, but if it looks like this\n                     *\n                     * 2: {\n                     *     'name': 'keyword',\n                     *     'matches': {\n                     *          'name': 'special',\n                     *          'pattern': /whatever/g\n                     *      }\n                     * }\n                     *\n                     * we treat the 'matches' part as the pattern and keep\n                     * the name around to wrap it with later\n                     */\n                    process_group = group['name'] && group['matches'] ? group['matches'] : group,\n\n                    /**\n                     * takes the code block matched at this group, replaces it\n                     * with the highlighted block, and optionally wraps it with\n                     * a span with a name\n                     *\n                     * @param {string} block\n                     * @param {string} replace_block\n                     * @param {string|null} match_name\n                     */\n                    _replaceAndContinue = function(block, replace_block, match_name) {\n                        replacement = _replaceAtPosition(_indexOfGroup(match, group_keys[i]), block, match_name ? _wrapCodeInSpan(match_name, replace_block) : replace_block, replacement);\n                        processNextGroup();\n                    };\n\n                // if this is a sublanguage go and process the block using that language\n                if (language) {\n                    return _highlightBlockForLanguage(block, language, function(code) {\n                        _replaceAndContinue(block, code);\n                    });\n                }\n\n                // if this is a string then this match is directly mapped to selector\n                // so all we have to do is wrap it in a span and continue\n                if (typeof group === 'string') {\n                    return _replaceAndContinue(block, block, group);\n                }\n\n                // the process group can be a single pattern or an array of patterns\n                // _processCodeWithPatterns always expects an array so we convert it here\n                _processCodeWithPatterns(block, process_group.length ? process_group : [process_group], function(code) {\n                    _replaceAndContinue(block, code, group['matches'] ? group['name'] : 0);\n                });\n            };\n\n        processGroup(0, group_keys, onMatchSuccess);\n    }\n\n    /**\n     * should a language bypass the default patterns?\n     *\n     * if you call Rainbow.extend() and pass true as the third argument\n     * it will bypass the defaults\n     */\n    function _bypassDefaultPatterns(language)\n    {\n        return bypass_defaults[language];\n    }\n\n    /**\n     * returns a list of regex patterns for this language\n     *\n     * @param {string} language\n     * @returns {Array}\n     */\n    function _getPatternsForLanguage(language) {\n        var patterns = language_patterns[language] || [],\n            default_patterns = language_patterns[DEFAULT_LANGUAGE] || [];\n\n        return _bypassDefaultPatterns(language) ? patterns : patterns.concat(default_patterns);\n    }\n\n    /**\n     * substring replace call to replace part of a string at a certain position\n     *\n     * @param {number} position         the position where the replacement should happen\n     * @param {string} replace          the text we want to replace\n     * @param {string} replace_with     the text we want to replace it with\n     * @param {string} code             the code we are doing the replacing in\n     * @returns {string}\n     */\n    function _replaceAtPosition(position, replace, replace_with, code) {\n        var sub_string = code.substr(position);\n        return code.substr(0, position) + sub_string.replace(replace, replace_with);\n    }\n\n   /**\n     * sorts an object by index descending\n     *\n     * @param {Object} object\n     * @return {Array}\n     */\n    function keys(object) {\n        var locations = [],\n            replacement,\n            pos;\n\n        for(var location in object) {\n            if (object.hasOwnProperty(location)) {\n                locations.push(location);\n            }\n        }\n\n        // numeric descending\n        return locations.sort(function(a, b) {\n            return b - a;\n        });\n    }\n\n    /**\n     * processes a block of code using specified patterns\n     *\n     * @param {string} code\n     * @param {Array} patterns\n     * @returns void\n     */\n    function _processCodeWithPatterns(code, patterns, callback)\n    {\n        // we have to increase the level here so that the\n        // replacements will not conflict with each other when\n        // processing sub blocks of code\n        ++CURRENT_LEVEL;\n\n        // patterns are processed one at a time through this function\n        function _workOnPatterns(patterns, i)\n        {\n            // still have patterns to process, keep going\n            if (i < patterns.length) {\n                return _processPattern(patterns[i]['pattern'], patterns[i], code, function() {\n                    _workOnPatterns(patterns, ++i);\n                });\n            }\n\n            // we are done processing the patterns\n            // process the replacements and update the DOM\n            _processReplacements(code, function(code) {\n\n                // when we are done processing replacements\n                // we are done at this level so we can go back down\n                delete replacements[CURRENT_LEVEL];\n                delete replacement_positions[CURRENT_LEVEL];\n                --CURRENT_LEVEL;\n                callback(code);\n            });\n        }\n\n        _workOnPatterns(patterns, 0);\n    }\n\n    /**\n     * process replacements in the string of code to actually update the markup\n     *\n     * @param {string} code         the code to process replacements in\n     * @param {Function} onComplete   what to do when we are done processing\n     * @returns void\n     */\n    function _processReplacements(code, onComplete) {\n\n        /**\n         * processes a single replacement\n         *\n         * @param {string} code\n         * @param {Array} positions\n         * @param {number} i\n         * @param {Function} onComplete\n         * @returns void\n         */\n        function _processReplacement(code, positions, i, onComplete) {\n            if (i < positions.length) {\n                ++replacement_counter;\n                var pos = positions[i],\n                    replacement = replacements[CURRENT_LEVEL][pos];\n                code = _replaceAtPosition(pos, replacement['replace'], replacement['with'], code);\n\n                // process next function\n                var next = function() {\n                    _processReplacement(code, positions, ++i, onComplete);\n                };\n\n                // use a timeout every 250 to not freeze up the UI\n                return replacement_counter % 250 > 0 ? next() : setTimeout(next, 0);\n            }\n\n            onComplete(code);\n        }\n\n        var string_positions = keys(replacements[CURRENT_LEVEL]);\n        _processReplacement(code, string_positions, 0, onComplete);\n    }\n\n    /**\n     * takes a string of code and highlights it according to the language specified\n     *\n     * @param {string} code\n     * @param {string} language\n     * @param {Function} onComplete\n     * @returns void\n     */\n    function _highlightBlockForLanguage(code, language, onComplete) {\n        var patterns = _getPatternsForLanguage(language);\n        _processCodeWithPatterns(_htmlEntities(code), patterns, onComplete);\n    }\n\n    /**\n     * highlight an individual code block\n     *\n     * @param {Array} code_blocks\n     * @param {number} i\n     * @returns void\n     */\n    function _highlightCodeBlock(code_blocks, i, onComplete) {\n        if (i < code_blocks.length) {\n            var block = code_blocks[i],\n                language = _getLanguageForBlock(block);\n\n            if (!_hasClass(block, 'rainbow') && language) {\n                language = language.toLowerCase();\n\n                _addClass(block, 'rainbow');\n\n                return _highlightBlockForLanguage(block.innerHTML, language, function(code) {\n                    block.innerHTML = code;\n\n                    // reset the replacement arrays\n                    replacements = {};\n                    replacement_positions = {};\n\n                    // if you have a listener attached tell it that this block is now highlighted\n                    if (onHighlight) {\n                        onHighlight(block, language);\n                    }\n\n                    // process the next block\n                    setTimeout(function() {\n                        _highlightCodeBlock(code_blocks, ++i, onComplete);\n                    }, 0);\n                });\n            }\n            return _highlightCodeBlock(code_blocks, ++i, onComplete);\n        }\n\n        if (onComplete) {\n            onComplete();\n        }\n    }\n\n    /**\n     * start highlighting all the code blocks\n     *\n     * @returns void\n     */\n    function _highlight(node, onComplete) {\n\n        // the first argument can be an Event or a DOM Element\n        // I was originally checking instanceof Event but that makes it break\n        // when using mootools\n        //\n        // @see https://github.com/ccampbell/rainbow/issues/32\n        //\n        node = node && typeof node.getElementsByTagName == 'function' ? node : document;\n\n        var pre_blocks = node.getElementsByTagName('pre'),\n            code_blocks = node.getElementsByTagName('code'),\n            i,\n            final_pre_blocks = [],\n            final_code_blocks = [];\n\n        // first loop through all pre blocks to find which ones to highlight\n        // also strip whitespace\n        for (i = 0; i < pre_blocks.length; ++i) {\n\n            // strip whitespace around code tags when they are inside of a pre tag\n            // this makes the themes look better because you can't accidentally\n            // add extra linebreaks at the start and end\n            //\n            // when the pre tag contains a code tag then strip any extra whitespace\n            // for example\n            // <pre>\n            //      <code>var foo = true;</code>\n            // </pre>\n            //\n            // will become\n            // <pre><code>var foo = true;</code></pre>\n            //\n            // if you want to preserve whitespace you can use a pre tag on its own\n            // without a code tag inside of it\n            if (pre_blocks[i].getElementsByTagName('code').length) {\n                pre_blocks[i].innerHTML = pre_blocks[i].innerHTML.replace(/^\\s+/, '').replace(/\\s+$/, '');\n                continue;\n            }\n\n            // if the pre block has no code blocks then we are going to want to\n            // process it directly\n            final_pre_blocks.push(pre_blocks[i]);\n        }\n\n        // @see http://stackoverflow.com/questions/2735067/how-to-convert-a-dom-node-list-to-an-array-in-javascript\n        // we are going to process all <code> blocks\n        for (i = 0; i < code_blocks.length; ++i) {\n            final_code_blocks.push(code_blocks[i]);\n        }\n\n        _highlightCodeBlock(final_code_blocks.concat(final_pre_blocks), 0, onComplete);\n    }\n\n    /**\n     * public methods\n     */\n    return {\n\n        /**\n         * extends the language pattern matches\n         *\n         * @param {*} language     name of language\n         * @param {*} patterns      array of patterns to add on\n         * @param {boolean|null} bypass      if true this will bypass the default language patterns\n         */\n        extend: function(language, patterns, bypass) {\n\n            // if there is only one argument then we assume that we want to\n            // extend the default language rules\n            if (arguments.length == 1) {\n                patterns = language;\n                language = DEFAULT_LANGUAGE;\n            }\n\n            bypass_defaults[language] = bypass;\n            language_patterns[language] = patterns.concat(language_patterns[language] || []);\n        },\n\n        /**\n         * call back to let you do stuff in your app after a piece of code has been highlighted\n         *\n         * @param {Function} callback\n         */\n        onHighlight: function(callback) {\n            onHighlight = callback;\n        },\n\n        /**\n         * method to set a global class that will be applied to all spans\n         *\n         * @param {string} class_name\n         */\n        addClass: function(class_name) {\n            global_class = class_name;\n        },\n\n        /**\n         * starts the magic rainbow\n         *\n         * @returns void\n         */\n        color: function() {\n\n            // if you want to straight up highlight a string you can pass the string of code,\n            // the language, and a callback function\n            if (typeof arguments[0] == 'string') {\n                return _highlightBlockForLanguage(arguments[0], arguments[1], arguments[2]);\n            }\n\n            // if you pass a callback function then we rerun the color function\n            // on all the code and call the callback function on complete\n            if (typeof arguments[0] == 'function') {\n                return _highlight(0, arguments[0]);\n            }\n\n            // otherwise we use whatever node you passed in with an optional\n            // callback function as the second parameter\n            _highlight(arguments[0], arguments[1]);\n        }\n    };\n}) ();\n\n/**\n * adds event listener to start highlighting\n */\n(function() {\n    if (document.addEventListener) {\n        return document.addEventListener('DOMContentLoaded', Rainbow.color, false);\n    }\n    window.attachEvent('onload', Rainbow.color);\n}) ();\n\n// When using Google closure compiler in advanced mode some methods\n// get renamed.  This keeps a public reference to these methods so they can\n// still be referenced from outside this library.\nRainbow[\"onHighlight\"] = Rainbow.onHighlight;\nRainbow[\"addClass\"] = Rainbow.addClass;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/assets/libs/rainbow.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\n * Generic language patterns\n *\n * @author Craig Campbell\n * @version 1.0.11\n */\nRainbow.extend([\n    {\n        'matches': {\n            1: [\n                {\n                    'name': 'keyword.operator',\n                    'pattern': /\\=|\\+/g\n                },\n                {\n                    'name': 'keyword.dot',\n                    'pattern': /\\./g\n                }\n            ],\n            2: {\n                'name': 'string',\n                'matches': {\n                    'name': 'constant.character.escape',\n                    'pattern': /\\\\('|\"){1}/g\n                }\n            }\n        },\n        'pattern': /(\\(|\\s|\\[|\\=|:|\\+|\\.)(('|\")([^\\\\\\1]|\\\\.)*?(\\3))/gm\n    },\n    {\n        'name': 'comment',\n        'pattern': /\\/\\*[\\s\\S]*?\\*\\/|(\\/\\/|\\#)[\\s\\S]*?$/gm\n    },\n    {\n        'name': 'constant.numeric',\n        'pattern': /\\b(\\d+(\\.\\d+)?(e(\\+|\\-)?\\d+)?(f|d)?|0x[\\da-f]+)\\b/gi\n    },\n    {\n        'matches': {\n            1: 'keyword'\n        },\n        'pattern': /\\b(and|array|as|b(ool(ean)?|reak)|c(ase|atch|har|lass|on(st|tinue))|d(ef|elete|o(uble)?)|e(cho|lse(if)?|xit|xtends|xcept)|f(inally|loat|or(each)?|unction)|global|if|import|int(eger)?|long|new|object|or|pr(int|ivate|otected)|public|return|self|st(ring|ruct|atic)|switch|th(en|is|row)|try|(un)?signed|var|void|while)(?=\\(|\\b)/gi\n    },\n    {\n        'name': 'constant.language',\n        'pattern': /true|false|null/g\n    },\n    {\n        'name': 'keyword.operator',\n        'pattern': /\\+|\\!|\\-|&(gt|lt|amp);|\\||\\*|\\=/g\n    },\n    {\n        'matches': {\n            1: 'function.call'\n        },\n        'pattern': /(\\w+?)(?=\\()/g\n    },\n    {\n        'matches': {\n            1: 'storage.function',\n            2: 'entity.name.function'\n        },\n        'pattern': /(function)\\s(.*?)(?=\\()/g\n    }\n]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/assets/libs/rainbow.generic.js\n ** module id = 8\n ** module chunks = 0 2\n **/","/**\n * GO Language\n *\n * @author Javier Aguirre\n * @version 1.0\n */\nRainbow.extend('go', [\n    {\n        'matches': {\n            1: {\n                'name': 'keyword.operator',\n                'pattern': /\\=/g\n            },\n            2: {\n                'name': 'string',\n                'matches': {\n                    'name': 'constant.character.escape',\n                    'pattern': /\\\\(`|\"){1}/g\n                }\n            }\n        },\n        'pattern': /(\\(|\\s|\\[|\\=|:)((`|\")([^\\\\\\1]|\\\\.)*?(\\3))/gm\n    },\n    {\n        'name': 'comment',\n        'pattern': /\\/\\*[\\s\\S]*?\\*\\/|(\\/\\/)[\\s\\S]*?$/gm\n    },\n    {\n        'name': 'constant.numeric',\n        'pattern': /\\b(\\d+(\\.\\d+)?(e(\\+|\\-)?\\d+)?(f|d)?|0x[\\da-f]+)\\b/gi\n    },\n    {\n        'matches': {\n            1: 'keyword'\n        },\n        'pattern': /\\b(break|c(ase|onst|ontinue)|d(efault|efer)|else|fallthrough|for|go(to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)(?=\\(|\\b)/gi\n    },\n    {\n        'name': 'constant.language',\n        'pattern': /true|false|null|string|byte|rune|u?int(8|16|32|64)?|float(32|64)|complex(64|128)/g\n    },\n    {\n        'name': 'keyword.operator',\n        'pattern': /\\+|\\!|\\-|&(gt|lt|amp);|\\||\\*|\\:?=/g\n    },\n    {\n        'matches': {\n            1: 'function.call'\n        },\n        'pattern': /(\\w+?)(?=\\()/g\n    },\n    {\n        'matches': {\n            1: 'storage.function',\n            2: 'entity.name.function'\n        },\n        'pattern': /(func)\\s(.*?)(?=\\()/g\n    }\n]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/assets/libs/rainbow.go.js\n ** module id = 9\n ** module chunks = 0 2\n **/","/**\n * Javascript patterns\n *\n * @author Craig Campbell\n * @version 1.0.9\n */\nRainbow.extend('javascript', [\n\n    /**\n     * matches $. or $(\n     */\n    {\n        'name': 'selector',\n        'pattern': /(\\s|^)\\$(?=\\.|\\()/g\n    },\n    {\n        'name': 'support',\n        'pattern': /\\b(window|document)\\b/g\n    },\n    {\n        'matches': {\n            1: 'support.property'\n        },\n        'pattern': /\\.(length|node(Name|Value))\\b/g\n    },\n    {\n        'matches': {\n            1: 'support.function'\n        },\n        'pattern': /(setTimeout|setInterval)(?=\\()/g\n\n    },\n    {\n        'matches': {\n            1: 'support.method'\n        },\n        'pattern': /\\.(getAttribute|push|getElementById|getElementsByClassName|log|setTimeout|setInterval)(?=\\()/g\n    },\n\n    /**\n     * matches any escaped characters inside of a js regex pattern\n     *\n     * @see https://github.com/ccampbell/rainbow/issues/22\n     *\n     * this was causing single line comments to fail so it now makes sure\n     * the opening / is not directly followed by a *\n     *\n     * @todo check that there is valid regex in match group 1\n     */\n    {\n        'name': 'string.regexp',\n        'matches': {\n            1: 'string.regexp.open',\n            2: {\n                'name': 'constant.regexp.escape',\n                'pattern': /\\\\(.){1}/g\n            },\n            3: 'string.regexp.close',\n            4: 'string.regexp.modifier'\n        },\n        'pattern': /(\\/)(?!\\*)(.+)(\\/)([igm]{0,3})/g\n    },\n\n    /**\n     * matches runtime function declarations\n     */\n    {\n        'matches': {\n            1: 'storage',\n            3: 'entity.function'\n        },\n        'pattern': /(var)?(\\s|^)(\\S*)(?=\\s?=\\s?function\\()/g\n    },\n\n    /**\n     * matches constructor call\n     */\n    {\n        'matches': {\n            1: 'keyword',\n            2: 'entity.function'\n        },\n        'pattern': /(new)\\s+(.*)(?=\\()/g\n    },\n\n    /**\n     * matches any function call in the style functionName: function()\n     */\n    {\n        'name': 'entity.function',\n        'pattern': /(\\w+)(?=:\\s{0,}function)/g\n    }\n]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/assets/libs/rainbow.javascript.js\n ** module id = 10\n ** module chunks = 0 2\n **/","/**\n * PHP patterns\n *\n * @author Craig Campbell\n * @version 1.0.8\n */\nRainbow.extend('php', [\n    {\n        'name': 'support',\n        'pattern': /\\becho\\b/g\n    },\n    {\n        'matches': {\n            1: 'variable.dollar-sign',\n            2: 'variable'\n        },\n        'pattern': /(\\$)(\\w+)\\b/g\n    },\n    {\n        'name': 'constant.language',\n        'pattern': /true|false|null/ig\n    },\n    {\n        'name': 'constant',\n        'pattern': /\\b[A-Z0-9_]{2,}\\b/g\n    },\n    {\n        'name': 'keyword.dot',\n        'pattern': /\\./g\n    },\n    {\n        'name': 'keyword',\n        'pattern': /\\b(die|end(for(each)?|switch|if)|case|require(_once)?|include(_once)?)(?=\\(|\\b)/g\n    },\n    {\n        'matches': {\n            1: 'keyword',\n            2: {\n                'name': 'support.class',\n                'pattern': /\\w+/g\n            }\n        },\n        'pattern': /(instanceof)\\s([^\\$].*?)(\\)|;)/g\n    },\n\n    /**\n     * these are the top 50 most used PHP functions\n     * found from running a script and checking the frequency of each function\n     * over a bunch of popular PHP frameworks then combining the results\n     */\n    {\n        'matches': {\n            1: 'support.function'\n        },\n        'pattern': /\\b(array(_key_exists|_merge|_keys|_shift)?|isset|count|empty|unset|printf|is_(array|string|numeric|object)|sprintf|each|date|time|substr|pos|str(len|pos|tolower|_replace|totime)?|ord|trim|in_array|implode|end|preg_match|explode|fmod|define|link|list|get_class|serialize|file|sort|mail|dir|idate|log|intval|header|chr|function_exists|dirname|preg_replace|file_exists)(?=\\()/g\n    },\n    {\n        'name': 'variable.language.php-tag',\n        'pattern': /(&lt;\\?(php)?|\\?&gt;)/g\n    },\n    {\n        'matches': {\n            1: 'keyword.namespace',\n            2: {\n                'name': 'support.namespace',\n                'pattern': /\\w+/g\n            }\n        },\n        'pattern': /\\b(namespace|use)\\s(.*?);/g\n    },\n    {\n        'matches': {\n            1: 'storage.modifier',\n            2: 'storage.class',\n            3: 'entity.name.class',\n            4: 'storage.modifier.extends',\n            5: 'entity.other.inherited-class',\n            6: 'storage.modifier.extends',\n            7: 'entity.other.inherited-class'\n        },\n        'pattern': /\\b(abstract|final)?\\s?(class|interface|trait)\\s(\\w+)(\\sextends\\s)?([\\w\\\\]*)?(\\simplements\\s)?([\\w\\\\]*)?\\s?\\{?(\\n|\\})/g\n    },\n    {\n        'name': 'keyword.static',\n        'pattern': /self::|static::/g\n    },\n    {\n        'matches': {\n            1: 'storage.function',\n            2: 'support.magic'\n        },\n        'pattern': /(function)\\s(__.*?)(?=\\()/g\n    },\n    {\n        'matches': {\n            1: 'keyword.new',\n            2: {\n                'name': 'support.class',\n                'pattern': /\\w+/g\n            }\n        },\n        'pattern': /\\b(new)\\s([^\\$].*?)(?=\\)|\\(|;)/g\n    },\n    {\n        'matches': {\n            1: {\n                'name': 'support.class',\n                'pattern': /\\w+/g\n            },\n            2: 'keyword.static'\n        },\n        'pattern': /([\\w\\\\]*?)(::)(?=\\b|\\$)/g\n    },\n    {\n        'matches': {\n            2: {\n                'name': 'support.class',\n                'pattern': /\\w+/g\n            }\n        },\n        'pattern': /(\\(|,\\s?)([\\w\\\\]*?)(?=\\s\\$)/g\n    }\n]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/assets/libs/rainbow.php.js\n ** module id = 11\n ** module chunks = 0 2\n **/","/**\n * Shell patterns\n *\n * @author Matthew King\n * @author Craig Campbell\n * @version 1.0.3\n */\nRainbow.extend('shell', [\n    /**\n     * This handles the case where subshells contain quotes.\n     * For example: `\"$(resolve_link \"$name\" || true)\"`.\n     *\n     * Caveat: This really should match balanced parentheses, but cannot.\n     * @see http://stackoverflow.com/questions/133601/can-regular-expressions-be-used-to-match-nested-patterns\n     */\n    {\n        'name': 'shell',\n        'matches': {\n            1: {\n                'language': 'shell'\n            }\n        },\n        'pattern': /\\$\\(([\\s\\S]*?)\\)/gm\n    },\n    {\n        'matches': {\n            2: 'string'\n        },\n        'pattern': /(\\(|\\s|\\[|\\=)(('|\")[\\s\\S]*?(\\3))/gm\n    },\n    {\n        'name': 'keyword.operator',\n        'pattern': /&lt;|&gt;|&amp;/g\n    },\n    {\n        'name': 'comment',\n        'pattern': /\\#[\\s\\S]*?$/gm\n    },\n    {\n        'name': 'storage.function',\n        'pattern': /(.+?)(?=\\(\\)\\s{0,}\\{)/g\n    },\n    /**\n     * Environment variables\n     */\n    {\n        'name': 'support.command',\n        'pattern': /\\b(echo|rm|ls|(mk|rm)dir|cd|find|cp|exit|pwd|exec|trap|source|shift|unset)/g\n    },\n    {\n        'matches': {\n            1: 'keyword'\n        },\n        'pattern': /\\b(break|case|continue|do|done|elif|else|esac|eval|export|fi|for|function|if|in|local|return|set|then|unset|until|while)(?=\\(|\\b)/g\n    }\n], true);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/assets/libs/rainbow.shell.js\n ** module id = 12\n ** module chunks = 0 2\n **/"],"sourceRoot":"","file":"./public/assets/js/rainbow.js"}